<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HSM-Tera | Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    tailwind.config = { 
      theme: { 
        extend: { 
          colors: { 
            brand: { 
              50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b' 
            }, 
            success: '#10b981', 
            danger: '#dc2626', 
            warning: '#f59e0b' 
          }, 
          boxShadow: { 
            card: '0 10px 20px -10px rgba(16,185,129,0.25), 0 4px 12px -6px rgba(0,0,0,0.15)' 
          } 
        } 
      } 
    };
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style> 
    html, body { 
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; 
    } 
  </style>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdn.tailwindcss.com https://fonts.googleapis.com https://fonts.gstatic.com https://cdn.jsdelivr.net; script-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
  <script src="../components/navbar.js"></script>
</head>
<body class="min-h-screen bg-gradient-to-b from-emerald-50 via-white to-white transition-opacity duration-300 opacity-0">
  <!-- Navbar Container -->
  <div id="navbar-container"></div>

  <main class="max-w-7xl mx-auto px-4 py-8">
    <!-- Header Section -->
    <div class="flex items-center justify-between mb-6">
      <h1 class="text-xl font-semibold text-slate-800">Dashboard</h1>
      <div class="flex items-center gap-4">
        <!-- Scheme Indicator -->
        <div id="schemeIndicator" class="hidden">
          <div class="flex items-center space-x-2 px-3 py-2 bg-brand-100 rounded-lg border border-brand-200">
            <div class="w-2 h-2 bg-brand-500 rounded-full"></div>
            <span id="currentSchemeName" class="text-sm font-medium text-brand-700">Loading...</span>
            <button onclick="switchScheme()" class="text-brand-600 hover:text-brand-800 text-xs underline">Switch</button>
          </div>
        </div>
        
        <!-- View Month Section -->
        <div class="flex items-center gap-3 bg-gradient-to-r from-brand-50 to-emerald-50 rounded-xl border border-brand-200 px-4 py-3 shadow-lg ring-1 ring-brand-100">
          <div class="flex items-center justify-center w-8 h-8 bg-brand-100 rounded-lg">
            <svg class="w-5 h-5 text-brand-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
          </div>
          <span class="text-brand-700 font-semibold">View Month:</span>
          <select id="monthSelector" class="px-3 py-2 border border-brand-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-brand-500 focus:border-brand-500 text-sm bg-white shadow-sm font-medium text-brand-800">
            <option value="">Select Month</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Dashboard Cards -->
    <div class="grid md:grid-cols-4 gap-4 mb-6">
      <!-- Total Customers Card -->
      <div class="rounded-2xl p-[1px] bg-gradient-to-br from-brand-300/50 via-brand-100 to-transparent">
        <div class="bg-white rounded-2xl border border-slate-100 p-4 shadow-card cursor-pointer hover:shadow-lg transition-all duration-200" onclick="navigateToCustomers()">
            <div class="flex items-center justify-between">
            <div class="flex-1">
              <div class="text-sm text-slate-500">Total Active Customers</div>
              <div class="mt-1 text-2xl font-semibold" data-countup data-countup-value="0" id="totalCustomers">0</div>
              </div>
            <div class="flex-shrink-0 ml-3">
              <svg class="w-8 h-8 text-brand-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
                </svg>
              </div>
            </div>
          </div>
      </div>

      <!-- Unpaid Card -->
      <div class="rounded-2xl p-[1px] bg-gradient-to-br from-red-300/50 via-red-100 to-transparent">
        <div class="bg-white rounded-2xl border border-slate-100 p-4 shadow-card">
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <div class="text-sm text-slate-500">Unpaid (<span id="unpaidMonthLabel">This Month</span>)</div>
              <div class="mt-1 text-2xl font-semibold text-danger" data-countup data-countup-value="0" id="unpaidThisMonth">0</div>
            </div>
            <div class="flex-shrink-0 ml-3">
              <svg class="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
              </svg>
            </div>
          </div>
        </div>
      </div>

      <!-- Paid Card -->
      <div class="rounded-2xl p-[1px] bg-gradient-to-br from-green-300/50 via-green-100 to-transparent">
        <div class="bg-white rounded-2xl border border-slate-100 p-4 shadow-card">
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <div class="text-sm text-slate-500">Paid (<span id="paidMonthLabel">This Month</span>)</div>
              <div class="mt-1 text-2xl font-semibold text-success" data-countup data-countup-value="0" id="paidThisMonth">0</div>
            </div>
            <div class="flex-shrink-0 ml-3">
              <svg class="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
            </div>
          </div>
        </div>
      </div>

      <!-- Total Collected Card -->
      <div class="rounded-2xl p-[1px] bg-gradient-to-br from-blue-300/50 via-blue-100 to-transparent">
        <div class="bg-white rounded-2xl border border-slate-100 p-4 shadow-card">
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <div class="text-sm text-slate-500">Collected (<span id="collectedMonthLabel">This Month</span>)</div>
              <div class="mt-1 text-2xl font-semibold text-blue-600" data-countup data-countup-value="0" data-countup-prefix="₹ " id="totalCollected">₹ 0</div>
            </div>
            <div class="flex-shrink-0 ml-3">
              <svg class="w-8 h-8 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
              </svg>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chart Section -->
    <div class="rounded-2xl overflow-hidden ring-1 ring-slate-200 bg-white">
      <div class="p-4 border-b border-slate-200 bg-gradient-to-r from-brand-50 to-transparent">
        <div class="flex items-center justify-between">
          <h2 class="text-lg font-semibold text-slate-800">Monthly Collection Overview</h2>
          <div class="flex items-center gap-2 text-sm text-slate-500">
            <div class="w-3 h-3 rounded-full bg-brand-500"></div>
            <span>Amount Collected</span>
          </div>
        </div>
      </div>
      <div class="p-6">
        <div class="h-80">
          <canvas id="monthlyChart"></canvas>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Fade in animation
    (function() {
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      function fadeIn() {
        if (prefersReduced) return document.body.classList.remove('opacity-0');
        requestAnimationFrame(() => document.body.classList.remove('opacity-0'));
      }
      document.addEventListener('DOMContentLoaded', fadeIn);
    })();

    // Count-up animation
    (function() {
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      function animateCount(el) {
        const target = parseFloat(el.getAttribute('data-countup-value') || '0');
        const prefix = el.getAttribute('data-countup-prefix') || '';
        const duration = 900; // ms
        const start = performance.now();
        const isCurrency = !!prefix;
        function step(now) {
          const progress = Math.min(1, (now - start) / duration);
          const ease = 1 - Math.pow(1 - progress, 3);
          const value = Math.floor(target * ease);
          el.textContent = isCurrency ? `${prefix}${value.toLocaleString('en-IN')}` : value.toLocaleString('en-IN');
          if (progress < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }
      function initCountups() {
        if (prefersReduced) return;
        document.querySelectorAll('[data-countup]').forEach(animateCount);
      }
      window.initCountups = initCountups; // Make it globally accessible
      window.addEventListener('DOMContentLoaded', initCountups);
    })();

    // Global variables
    let customersData = [];
    let paymentsData = [];
    let winnersData = [];
    let selectedMonthYear = '';
    let defaultStartDate = '2024-12-15';
    let isLoadingDashboardData = false;
    let monthSelectorListenerSetup = false;

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Dashboard: Initializing...');
      
      // Check authentication
      checkAuthentication();
      
      // Load dashboard data
      loadDashboardData();
      
      // Load scheme indicator
      loadSelectedSchemeIndicator();
      
      
      console.log('Dashboard: Initialization completed');
    });

    // Check authentication
    function checkAuthentication() {
      const token = localStorage.getItem('authToken');
      if (!token) {
        console.log('Dashboard: No auth token found, redirecting to login');
        window.location.href = 'login.html';
        return;
      }
      
      // Validate token with backend
      if (window.electronAPI && window.electronAPI.auth) {
        window.electronAPI.auth.validateSession(token)
          .then(result => {
            if (!result.valid) {
              console.log('Dashboard: Token validation failed, redirecting to login');
              localStorage.removeItem('authToken');
              localStorage.removeItem('user');
              window.location.href = 'login.html';
            } else {
              console.log('Dashboard: Token validated successfully');
            }
          })
          .catch(error => {
            console.error('Dashboard: Error validating token:', error);
            localStorage.removeItem('authToken');
            localStorage.removeItem('user');
            window.location.href = 'login.html';
          });
      }
    }

    // Load dashboard data
    async function loadDashboardData() {
      if (isLoadingDashboardData) {
        console.log('Dashboard: Already loading data, skipping...');
        return;
      }
      
      isLoadingDashboardData = true;
      console.log('Dashboard: Loading dashboard data...');
      
      try {
        // Load default start date from environment first, then override with scheme start date
        await loadDefaultStartDate();
        await loadSchemeStartDate();
        
        // Load customers, payments, and winners data
        await Promise.all([
          loadCustomersData(),
          loadPaymentsData(),
          loadWinnersData()
        ]);
        
        // Generate month options after loading data
        await generateMonthOptions();
        
        // Debug: Log all loaded data
        console.log('Dashboard: === DATA LOADING SUMMARY ===');
        console.log('Dashboard: Selected Scheme ID:', localStorage.getItem('selectedSchemeId'));
        console.log('Dashboard: Customers loaded:', customersData.length);
        console.log('Dashboard: Payments loaded:', paymentsData.length);
        console.log('Dashboard: Winners loaded:', winnersData.length);
        console.log('Dashboard: Selected month year:', selectedMonthYear);
        console.log('Dashboard: ================================');
        
        // Note: updateDashboardCards() is now called from generateMonthOptions() after setting default month
        
        // Create chart
        createMonthlyCollectionChart();
        
        console.log('Dashboard: Data loading completed successfully');
        
      } catch (error) {
        console.error('Dashboard: Error loading data:', error);
      } finally {
        isLoadingDashboardData = false;
      }
    }

    // Load default start date from environment
    async function loadDefaultStartDate() {
      try {
        if (window.electronAPI && window.electronAPI.getDefaultStartDate) {
          const result = await window.electronAPI.getDefaultStartDate();
          console.log('Dashboard: Default start date result:', result);
          
          // Extract the actual date string from the result
          if (result && typeof result === 'object' && result.startDate) {
            defaultStartDate = result.startDate;
          } else if (typeof result === 'string') {
            defaultStartDate = result;
          }
          
          console.log('Dashboard: Environment default start date loaded:', defaultStartDate);
        }
      } catch (error) {
        console.error('Dashboard: Error getting default start date:', error);
      }
    }

    // Load scheme start date (preferred over environment default)
    async function loadSchemeStartDate() {
      try {
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        if (selectedSchemeId && window.electronAPI && window.electronAPI.schemes) {
          const result = await window.electronAPI.schemes.getById(selectedSchemeId);
          if (result.success && result.scheme && result.scheme.start_date) {
            defaultStartDate = result.scheme.start_date;
            console.log('Dashboard: Scheme start date loaded:', defaultStartDate);
          } else {
            console.log('Dashboard: No scheme start date found, using environment default');
          }
        } else {
          console.log('Dashboard: No scheme selected, using environment default');
        }
      } catch (error) {
        console.error('Dashboard: Error getting scheme start date:', error);
      }
    }

    // Load customers data
    async function loadCustomersData() {
      try {
        console.log('Dashboard: Loading customers data...');
        
        if (!window.electronAPI || !window.electronAPI.customer) {
          console.log('Dashboard: electronAPI not available');
          return;
        }
        
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        const result = await window.electronAPI.customer.getAll(selectedSchemeId);
        console.log('Dashboard: Customers result:', result);
        
        if (result.success && result.customers) {
          customersData = result.customers;
          console.log('Dashboard: Loaded', customersData.length, 'customers');
        } else {
          customersData = [];
          console.log('Dashboard: No customers found');
        }
        
      } catch (error) {
        console.error('Dashboard: Error loading customers:', error);
        customersData = [];
      }
    }

    // Load payments data
    async function loadPaymentsData() {
      try {
        console.log('Dashboard: Loading payments data...');
        
        if (!window.electronAPI || !window.electronAPI.payment) {
          console.log('Dashboard: electronAPI not available');
          return;
        }
        
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        const result = await window.electronAPI.payment.getAll(selectedSchemeId);
        console.log('Dashboard: Payments result:', result);
        
        if (result.success && result.payments) {
          paymentsData = result.payments;
          console.log('Dashboard: Loaded', paymentsData.length, 'payments');
          console.log('Dashboard: Payments data:', paymentsData);
        } else {
          paymentsData = [];
          console.log('Dashboard: No payments found');
          console.log('Dashboard: Payments result:', result);
        }
        
      } catch (error) {
        console.error('Dashboard: Error loading payments:', error);
        paymentsData = [];
      }
    }

    // Load winners data
    async function loadWinnersData() {
      try {
        console.log('Dashboard: Loading winners data...');
        
        if (!window.electronAPI || !window.electronAPI.winners) {
          console.log('Dashboard: electronAPI not available');
          return;
        }
        
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        const result = await window.electronAPI.winners.getAll(selectedSchemeId);
        console.log('Dashboard: Winners result:', result);
        
        if (result.success && result.winners) {
          winnersData = result.winners;
          console.log('Dashboard: Loaded', winnersData.length, 'winners');
        } else {
          winnersData = [];
          console.log('Dashboard: No winners found');
        }
        
      } catch (error) {
        console.error('Dashboard: Error loading winners:', error);
        winnersData = [];
      }
    }

    // Generate month options
    async function generateMonthOptions() {
      console.log('Dashboard: generateMonthOptions called');
      const monthSelector = document.getElementById('monthSelector');
      if (!monthSelector) {
        console.log('Dashboard: monthSelector element not found!');
        console.log('Dashboard: Available elements with "month" in ID:', Array.from(document.querySelectorAll('[id*="month"]')).map(el => el.id));
        return;
      }
      console.log('Dashboard: monthSelector element found');
      
      // Clear existing options
      monthSelector.innerHTML = '<option value="">Select Month</option>';
      
      // Get current month for smart default selection
      const currentDate = new Date();
      const currentYear = currentDate.getFullYear();
      const currentMonth = currentDate.getMonth() + 1; // JavaScript months are 0-based
      const currentMonthYear = `${currentYear}-${currentMonth.toString().padStart(2, '0')}`;
      
      console.log('Dashboard: Current date calculation:', {
        currentDate,
        currentYear,
        currentMonth,
        currentMonthYear
      });
      
      // Get scheme data (start date and duration) in a single API call
      let schemeStartDate = defaultStartDate;
      let schemeDuration = 30; // default
      
      try {
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        console.log('Dashboard: Selected scheme ID from localStorage:', selectedSchemeId);
        
        if (selectedSchemeId && window.electronAPI && window.electronAPI.schemes) {
          console.log('Dashboard: Calling schemes.getById for scheme:', selectedSchemeId);
          const result = await window.electronAPI.schemes.getById(selectedSchemeId);
          console.log('Dashboard: Scheme API result:', result);
          
          if (result.success && result.scheme) {
            console.log('Dashboard: Scheme data received:', result.scheme);
            
            if (result.scheme.start_date) {
              schemeStartDate = result.scheme.start_date;
              console.log('Dashboard: Using scheme start date:', schemeStartDate);
            } else {
              console.log('Dashboard: No scheme start date found, using environment default:', defaultStartDate);
            }
            if (result.scheme.duration) {
              schemeDuration = result.scheme.duration;
              console.log('Dashboard: Using scheme duration:', schemeDuration);
            }
          } else {
            console.log('Dashboard: No scheme found or API failed, using environment default start date:', defaultStartDate);
          }
        } else {
          console.log('Dashboard: No scheme selected or API not available, using environment default start date:', defaultStartDate);
        }
      } catch (error) {
        console.log('Dashboard: Error getting scheme data, using environment default start date:', defaultStartDate, error);
      }
      
      const startDate = new Date(schemeStartDate);
      const now = new Date();
      
      console.log('Dashboard: Scheme start date:', schemeStartDate);
      console.log('Dashboard: Start date object:', startDate);
      console.log('Dashboard: Current date:', now);
      console.log('Dashboard: Current month year:', currentMonthYear);
      
      // Generate months from start date for the full scheme duration (including future dates)
      let monthDate = new Date(startDate);
      let monthNumber = 1;
      let currentMonthOption = null;
      let optionsGenerated = 0;
      
      console.log('Dashboard: Generating months for duration:', schemeDuration);
      
      // Calculate end date (start date + duration)
      const endDate = new Date(startDate);
      endDate.setMonth(endDate.getMonth() + schemeDuration);
      
      console.log('Dashboard: Start date:', startDate);
      console.log('Dashboard: Scheme end date:', endDate);
      console.log('Dashboard: Current date:', now);
      console.log('Dashboard: Will generate all months including future dates');
      
      while (monthDate < endDate && optionsGenerated < schemeDuration) {
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const monthYear = `${monthDate.getFullYear()}-${String(monthDate.getMonth() + 1).padStart(2, '0')}`;
        const displayText = `${monthNames[monthDate.getMonth()]} ${monthDate.getFullYear()} (${monthNumber})`;
        
        const option = document.createElement('option');
        option.value = monthYear;
        option.textContent = displayText;
        monthSelector.appendChild(option);
        
        console.log('Dashboard: Generated option:', monthYear, displayText, 'Month date:', monthDate);
        
        // Track the current month option
        if (monthYear === currentMonthYear) {
          currentMonthOption = option;
          console.log('Dashboard: Found current month option:', monthYear);
        }
        
        // Move to next month
        monthDate.setMonth(monthDate.getMonth() + 1);
        monthNumber++;
        optionsGenerated++;
      }
      
      // Set default selection - prioritize current month if it's within scheme timeline
      console.log('Dashboard: === DEFAULT SELECTION LOGIC ===');
      console.log('Dashboard: currentMonthOption:', currentMonthOption);
      console.log('Dashboard: currentMonthYear:', currentMonthYear);
      console.log('Dashboard: monthSelector.options.length:', monthSelector.options.length);
      console.log('Dashboard: All options:', Array.from(monthSelector.options).map(opt => ({value: opt.value, text: opt.textContent, selected: opt.selected})));
      
      if (currentMonthOption) {
        currentMonthOption.selected = true;
        selectedMonthYear = currentMonthYear;
        console.log('Dashboard: ✅ Default month set to current month:', currentMonthYear);
      } else if (monthSelector.options.length > 1) {
        // If current month is not in scheme timeline, default to first month of scheme
        const firstOption = monthSelector.options[1]; // Skip the "Select Month" option
        firstOption.selected = true;
        selectedMonthYear = firstOption.value;
        console.log('Dashboard: ✅ Current month not in scheme timeline, defaulting to first month:', firstOption.value);
        console.log('Dashboard: First option details:', firstOption.value, firstOption.textContent);
      } else {
        console.log('Dashboard: ❌ No month options available for selection');
      }
      
      console.log('Dashboard: Final selectedMonthYear after logic:', selectedMonthYear);
      console.log('Dashboard: ======================================');
      
      // Force update the month selector display
      monthSelector.dispatchEvent(new Event('change'));
      
      // Verify the selection was applied
      console.log('Dashboard: === VERIFICATION ===');
      console.log('Dashboard: monthSelector.value after selection:', monthSelector.value);
      console.log('Dashboard: monthSelector.selectedIndex:', monthSelector.selectedIndex);
      console.log('Dashboard: selectedMonthYear:', selectedMonthYear);
      console.log('Dashboard: ===================');
      
      // Update dashboard cards immediately after setting default month
      if (selectedMonthYear) {
        console.log('Dashboard: Updating dashboard cards with default month:', selectedMonthYear);
        updateDashboardCards();
      }
      
      console.log('Dashboard: Generated', optionsGenerated, 'month options');
      console.log('Dashboard: Total options in selector:', monthSelector.options.length);
      console.log('Dashboard: Month selector options:', Array.from(monthSelector.options).map(opt => opt.textContent));
      
      // Setup event listener for month selector (only once)
      if (!monthSelectorListenerSetup) {
        setupMonthSelectorListener();
        monthSelectorListenerSetup = true;
      }
    }

    // Update dashboard cards
    function updateDashboardCards() {
      console.log('Dashboard: Updating cards for month:', selectedMonthYear);
      
      // Update month labels
      updateMonthLabels(selectedMonthYear);
      
      // Calculate stats for selected month
      const stats = calculateMonthlyStats(selectedMonthYear);
      
      // Update cards with animation
      updateCardWithAnimation('totalCustomers', stats.totalCustomers);
      updateCardWithAnimation('unpaidThisMonth', stats.unpaidThisMonth);
      updateCardWithAnimation('paidThisMonth', stats.paidThisMonth);
      updateCardWithAnimation('totalCollected', stats.totalCollected, '₹');
      
      console.log('Dashboard: Cards updated with stats:', stats);
    }

    // Update month labels to show the selected month
    function updateMonthLabels(monthYear) {
      if (!monthYear) return;
      
      // Parse the month year (format: YYYY-MM)
      const [year, monthNum] = monthYear.split('-');
      const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const monthIndex = parseInt(monthNum) - 1;
      const monthName = monthNames[monthIndex];
      const displayText = `${monthName} ${year}`;
      
      // Update all month labels
      const labels = ['unpaidMonthLabel', 'paidMonthLabel', 'collectedMonthLabel'];
      labels.forEach(labelId => {
        const element = document.getElementById(labelId);
        if (element) {
          element.textContent = displayText;
        }
      });
    }

    // Calculate monthly stats
    function calculateMonthlyStats(monthYear) {
      console.log('Dashboard: calculateMonthlyStats called with monthYear:', monthYear);
      console.log('Dashboard: paymentsData length:', paymentsData.length);
      console.log('Dashboard: customersData length:', customersData.length);
      console.log('Dashboard: winnersData length:', winnersData.length);
      
      if (!monthYear) {
        console.log('Dashboard: No monthYear provided, returning default stats');
        // For default stats, show all customers as active (no winners filtered yet)
        return {
          totalCustomers: customersData.length,
          unpaidThisMonth: 0,
          paidThisMonth: 0,
          totalCollected: 0
        };
      }
      
      // Log all payments data for debugging
      console.log('Dashboard: All payments data:', paymentsData);
      
      // Get payments for the selected month
      const monthPayments = paymentsData.filter(payment => payment.month_year === monthYear);
      console.log('Dashboard: Payments for month', monthYear, ':', monthPayments);
      
      // Get customers who paid for this month
      const paidCustomerIds = new Set(monthPayments.map(payment => payment.customer_id));
      console.log('Dashboard: Paid customer IDs for month', monthYear, ':', Array.from(paidCustomerIds));
      
      // Get winners and their winning months to exclude them only from future months
      const winnerMap = new Map();
      winnersData.forEach(winner => {
        winnerMap.set(winner.customer_id, winner.month_year);
      });
      console.log('Dashboard: Winner map:', Object.fromEntries(winnerMap));
      
      // Calculate stats - use active customers (exclude only if they won BEFORE this month)
      const activeCustomers = customersData.filter(customer => {
        const winnerMonth = winnerMap.get(customer.id);
        if (!winnerMonth) {
          // Customer is not a winner, so they're active
          return true;
        }
        // Customer is a winner, check if they won before this month
        // If they won before this month, exclude them (they're no longer active)
        // If they won in this month or later, include them (they're still active)
        return winnerMonth >= monthYear;
      });
      const totalActiveCustomers = activeCustomers.length;
      
      // Count active customers who paid
      const paidThisMonth = activeCustomers.filter(customer => paidCustomerIds.has(customer.id)).length;
      
      // Count active customers who didn't pay
      const unpaidThisMonth = activeCustomers.filter(customer => !paidCustomerIds.has(customer.id)).length;
      
      const totalCollected = monthPayments.reduce((sum, payment) => sum + (parseFloat(payment.amount) || 0), 0);
      
      const stats = {
        totalCustomers: totalActiveCustomers,
        unpaidThisMonth,
        paidThisMonth,
        totalCollected
      };
      
      console.log('Dashboard: Calculated stats:', stats);
      return stats;
    }

    // Update card with count-up animation
    function updateCardWithAnimation(elementId, value, prefix = '') {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      // Update the data attribute for count-up animation
      element.setAttribute('data-countup-value', value);
      if (prefix) {
        element.setAttribute('data-countup-prefix', prefix);
      }
      
      // Trigger count-up animation
      if (window.initCountups) {
        window.initCountups();
      }
    }

    // Create monthly collection chart
    function createMonthlyCollectionChart(payments = paymentsData) {
      const ctx = document.getElementById('monthlyChart');
      if (!ctx) return;
      
      // Destroy existing chart if it exists
      if (window.monthlyChartInstance) {
        window.monthlyChartInstance.destroy();
      }
      
      // Group payments by month_year
      const monthlyData = {};
      payments.forEach(payment => {
        const monthYear = payment.month_year;
        if (monthYear) {
          if (!monthlyData[monthYear]) {
            monthlyData[monthYear] = 0;
          }
          monthlyData[monthYear] += parseFloat(payment.amount) || 0;
        }
      });
      
      // Sort months chronologically
      const sortedMonths = Object.keys(monthlyData).sort();
      
      // Prepare chart data
      const labels = sortedMonths.map(monthYear => {
        const [year, month] = monthYear.split('-');
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        return `${monthNames[parseInt(month) - 1]} ${year}`;
      });
      
      const data = sortedMonths.map(monthYear => monthlyData[monthYear]);
      
      // Create chart
      window.monthlyChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Amount Collected',
            data: data,
            borderColor: '#10b981',
            backgroundColor: 'rgba(16, 185, 129, 0.1)',
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#10b981',
            pointBorderColor: '#ffffff',
            pointBorderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              },
              ticks: {
                callback: function(value) {
                  return '₹' + value.toLocaleString('en-IN');
                }
              }
            },
            x: {
              grid: {
                display: false
              }
            }
          },
          interaction: {
            intersect: false,
            mode: 'index'
          }
        }
      });
      
      console.log('Dashboard: Chart created with', labels.length, 'data points');
    }

    // Month selector change handler
    function setupMonthSelectorListener() {
      const monthSelector = document.getElementById('monthSelector');
      if (monthSelector) {
        console.log('Dashboard: Setting up month selector listener');
        console.log('Dashboard: Current monthSelector.value before cloning:', monthSelector.value);
        console.log('Dashboard: Current monthSelector.selectedIndex before cloning:', monthSelector.selectedIndex);
        
        // Store the current selection before cloning
        const currentValue = monthSelector.value;
        const currentSelectedIndex = monthSelector.selectedIndex;
        
        // Remove any existing event listeners by cloning the element
        const newMonthSelector = monthSelector.cloneNode(true);
        monthSelector.parentNode.replaceChild(newMonthSelector, monthSelector);
        
        // Restore the selection after cloning
        if (currentValue) {
          newMonthSelector.value = currentValue;
          console.log('Dashboard: Restored selection after cloning:', currentValue);
        }
        
        // Add the event listener to the new element
        newMonthSelector.addEventListener('change', function() {
          selectedMonthYear = this.value;
          console.log('Dashboard: Month changed to:', selectedMonthYear);
          updateDashboardCards();
        });
        
        console.log('Dashboard: Month selector listener setup complete');
        console.log('Dashboard: Final monthSelector.value after setup:', newMonthSelector.value);
      } else {
        console.log('Dashboard: ❌ Month selector element not found for listener setup');
      }
    }

    // Debug function - call from browser console: debugDashboard()
    window.debugDashboard = function() {
      console.log('=== DASHBOARD DEBUG INFO ===');
      console.log('Selected Scheme ID:', localStorage.getItem('selectedSchemeId'));
      console.log('Selected Month Year:', selectedMonthYear);
      console.log('Customers Data:', customersData);
      console.log('Payments Data:', paymentsData);
      console.log('Winners Data:', winnersData);
      
      if (selectedMonthYear) {
        const monthPayments = paymentsData.filter(payment => payment.month_year === selectedMonthYear);
        console.log('Payments for selected month (' + selectedMonthYear + '):', monthPayments);
        
        const paidCustomerIds = new Set(monthPayments.map(payment => payment.customer_id));
        console.log('Paid Customer IDs:', Array.from(paidCustomerIds));
        
        const totalCollected = monthPayments.reduce((sum, payment) => sum + (parseFloat(payment.amount) || 0), 0);
        console.log('Total Collected:', totalCollected);
      }
      console.log('============================');
    };

    // Smooth navigation
    (function() {
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      function fadeNavigate(event, href) {
        if (prefersReduced) return;
        event.preventDefault();
        document.body.classList.add('opacity-0');
        setTimeout(() => { window.location.href = href; }, 180);
      }
      document.addEventListener('click', function(e) {
        const a = e.target.closest('a[href]');
        if (!a) return;
        const url = new URL(a.href, window.location.href);
        const sameOrigin = url.origin === window.location.origin;
        if (sameOrigin) fadeNavigate(e, a.href);
      });
    })();


    // Navigation function for total customers card
    function navigateToCustomers() {
      if (window.electronAPI && window.electronAPI.navigation) {
        window.electronAPI.navigation.navigateTo('pages/customers.html');
      } else {
        window.location.href = 'customers.html';
      }
    }

    // Scheme indicator functions
    function showSchemeIndicator(schemePrefix) {
      const indicator = document.getElementById('schemeIndicator');
      const schemeNameSpan = document.getElementById('currentSchemeName');
      if (indicator && schemeNameSpan) {
        schemeNameSpan.textContent = schemePrefix;
        indicator.classList.remove('hidden');
      }
    }

    function hideSchemeIndicator() {
      const indicator = document.getElementById('schemeIndicator');
      if (indicator) {
        indicator.classList.add('hidden');
      }
    }

    function switchScheme() {
      window.location.href = 'scheme-selection.html';
    }

    // Load and show selected scheme indicator
    async function loadSelectedSchemeIndicator() {
      try {
        const selectedSchemeId = localStorage.getItem('selectedSchemeId');
        if (selectedSchemeId && window.electronAPI && window.electronAPI.schemes) {
          const result = await window.electronAPI.schemes.getById(selectedSchemeId);
          if (result.success && result.scheme) {
            showSchemeIndicator(result.scheme.prefix);
            // Note: Month options are already generated in loadDashboardData()
          } else {
            hideSchemeIndicator();
          }
        } else {
          hideSchemeIndicator();
        }
      } catch (error) {
        console.error('Error loading selected scheme:', error);
        hideSchemeIndicator();
      }
    }
  </script>
</body>
</html>